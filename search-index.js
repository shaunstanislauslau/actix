var searchIndex = {};
searchIndex["actix"] = {"doc":"Actix is a rust actors framework.","items":[[3,"SpawnHandle","actix","Spawned future handle. Could be used for cancelling spawned future.",null,null],[3,"Addr","","Address of the actor",null,null],[3,"Recipient","","`Recipient` type allows to send one specific message to an actor.",null,null],[3,"Arbiter","","Event loop controller",null,null],[3,"Context","","Actor execution context",null,null],[3,"ActorResponse","","Helper type for representing different type of message responses",null,null],[3,"MessageResult","","Helper type that implements `MessageResponse` trait",null,null],[12,"0","","",0,null],[3,"Response","","Helper type for representing different type of message responses",null,null],[3,"Supervisor","","Actor supervisor",null,null],[3,"System","","System is an actor which manages runtime.",null,null],[3,"SystemRuntime","","Helper object that runs System's event loop",null,null],[4,"ActorState","","Actor execution state",null,null],[13,"Started","","Actor is started.",1,null],[13,"Running","","Actor is running.",1,null],[13,"Stopping","","Actor is stopping.",1,null],[13,"Stopped","","Actor is stopped.",1,null],[4,"Running","","",null,null],[13,"Stop","","",2,null],[13,"Continue","","",2,null],[4,"MailboxError","","Set of error that can occurred during message delivery process",null,null],[13,"Closed","","",3,null],[13,"Timeout","","",3,null],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"actorstate"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"running"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"running"}],"output":{"name":"bool"}}],[11,"alive","","",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"spawnhandle"}}],[11,"hash","","",4,null],[11,"next","","Get next handle",4,{"inputs":[{"name":"self"}],"output":{"name":"spawnhandle"}}],[11,"default","","",4,{"inputs":[],"output":{"name":"spawnhandle"}}],[11,"started","","",5,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[11,"new","","Spawn new thread and run event loop in spawned thread. Returns address of newly created arbiter.",5,{"inputs":[{"name":"t"}],"output":{"generics":["arbiter"],"name":"addr"}}],[11,"set_system_reg","","",5,{"inputs":[{"name":"systemregistry"}],"output":null}],[11,"name","","Returns current arbiter's address",5,{"inputs":[],"output":{"name":"string"}}],[11,"arbiter","","Returns current arbiter's address",5,{"inputs":[],"output":{"generics":["arbiter"],"name":"addr"}}],[11,"system","","This function returns system address,",5,{"inputs":[],"output":{"generics":["system"],"name":"addr"}}],[11,"system_arbiter","","This function returns system address,",5,{"inputs":[],"output":{"generics":["arbiter"],"name":"addr"}}],[11,"registry","","This function returns arbiter's registry",5,{"inputs":[],"output":{"name":"systemregistry"}}],[11,"start","","Start new arbiter and then start actor in created arbiter. Returns `Addr<Syn, A>` of created actor.",5,{"inputs":[{"name":"f"}],"output":{"name":"addr"}}],[11,"handle","","",5,{"inputs":[{"name":"self"},{"name":"stoparbiter"},{"name":"context"}],"output":null}],[11,"handle","","",5,{"inputs":[{"name":"self"},{"name":"startactor"},{"name":"context"}],"output":{"name":"addr"}}],[11,"handle","","",5,{"inputs":[{"name":"self"},{"name":"execute"},{"name":"context"}],"output":{"name":"result"}}],[11,"stop","","",6,{"inputs":[{"name":"self"}],"output":null}],[11,"terminate","","",6,{"inputs":[{"name":"self"}],"output":null}],[11,"state","","",6,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[11,"spawn","","",6,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[11,"wait","","",6,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"waiting","","",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"cancel_future","","",6,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"address","","",6,{"inputs":[{"name":"self"}],"output":{"name":"addr"}}],[11,"create","","Create `Context` instance with actor factory method.",6,{"inputs":[{"name":"f"}],"output":{"name":"self"}}],[11,"handle","","Handle of the running future",6,{"inputs":[{"name":"self"}],"output":{"name":"spawnhandle"}}],[11,"set_mailbox_capacity","","Set mailbox capacity",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"handle","","",0,null],[11,"handle","","",7,null],[11,"async","","Create async response",8,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"reply","","Create response",8,{"inputs":[{"name":"result"}],"output":{"name":"self"}}],[11,"handle","","",8,null],[11,"reply","","Create response",9,{"inputs":[{"name":"result"}],"output":{"name":"self"}}],[11,"async","","Create async response",9,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"handle","","",9,null],[11,"start","","Start new supervised actor in current Arbiter.",10,{"inputs":[{"name":"f"}],"output":{"name":"addr"}}],[11,"start_in","","Start new supervised actor in arbiter's thread.",10,{"inputs":[{"name":"addr"},{"name":"f"}],"output":{"name":"addr"}}],[11,"new","","Create new system.",11,{"inputs":[{"name":"t"}],"output":{"name":"systemruntime"}}],[11,"run","","This function will start tokio runtime and will finish once the `SystemExit` message get received. Function `f` get called within tokio runtime context.",11,{"inputs":[{"name":"f"}],"output":{"name":"i32"}}],[11,"run","","This function will start event loop and will finish once the `SystemExit` message get received.",12,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"config","","",12,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"self"}}],[11,"handle","","",11,{"inputs":[{"name":"self"},{"name":"systemexit"},{"name":"context"}],"output":null}],[11,"pack","","",6,{"inputs":[{"name":"m"},{"generics":["sender"],"name":"option"}],"output":{"name":"envelope"}}],[11,"cause","","",3,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",3,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",7,{"inputs":[{"name":"addresssender"}],"output":{"name":"addr"}}],[11,"connected","","Indicates if actor is still alive",7,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"do_send","","Send message unconditionally",7,{"inputs":[{"name":"self"},{"name":"m"}],"output":null}],[11,"send","","Send asynchronous message and wait for response.",7,{"inputs":[{"name":"self"},{"name":"m"}],"output":{"name":"request"}}],[11,"recipient","","Get `Recipient` for specific message type",7,{"inputs":[{"name":"self"}],"output":{"name":"recipient"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"addr"}}],[11,"do_send","","Send message",13,{"inputs":[{"name":"self"},{"name":"m"}],"output":{"generics":["senderror"],"name":"result"}}],[11,"send","","Send message and asynchronously wait for response.",13,{"inputs":[{"name":"self"},{"name":"m"}],"output":{"name":"recipientrequest"}}],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"recipient"}}],[0,"actors","","Helper actors",null,null],[3,"Connect","actix::actors","",null,null],[3,"ConnectAddr","","",null,null],[12,"0","","",14,null],[3,"Connector","","",null,null],[3,"Resolve","","",null,null],[4,"ConnectorError","","",null,null],[13,"Resolver","","Failed to resolve the hostname",15,null],[13,"InvalidInput","","Address is invalid",15,null],[13,"Timeout","","Connecting took too long",15,null],[13,"IoError","","Connection io error",15,null],[11,"eq","","",16,{"inputs":[{"name":"self"},{"name":"resolve"}],"output":{"name":"bool"}}],[11,"ne","","",16,{"inputs":[{"name":"self"},{"name":"resolve"}],"output":{"name":"bool"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"host","","",16,{"inputs":[{"name":"t"}],"output":{"name":"resolve"}}],[11,"host_and_port","","",16,{"inputs":[{"name":"t"},{"name":"u16"}],"output":{"name":"resolve"}}],[11,"eq","","",17,{"inputs":[{"name":"self"},{"name":"connect"}],"output":{"name":"bool"}}],[11,"ne","","",17,{"inputs":[{"name":"self"},{"name":"connect"}],"output":{"name":"bool"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"host","","",17,{"inputs":[{"name":"t"}],"output":{"name":"connect"}}],[11,"host_and_port","","",17,{"inputs":[{"name":"t"},{"name":"u16"}],"output":{"name":"connect"}}],[11,"timeout","","Set connect timeout",17,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"connect"}}],[11,"eq","","",14,{"inputs":[{"name":"self"},{"name":"connectaddr"}],"output":{"name":"bool"}}],[11,"ne","","",14,{"inputs":[{"name":"self"},{"name":"connectaddr"}],"output":{"name":"bool"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cause","","",15,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",15,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",18,{"inputs":[{"name":"resolverconfig"},{"name":"resolveropts"}],"output":{"generics":["connector","resolveerror"],"name":"result"}}],[11,"started","","",18,null],[11,"default","","",18,{"inputs":[],"output":{"name":"connector"}}],[11,"handle","","",18,null],[11,"handle","","",18,null],[11,"handle","","",18,null],[0,"signal","","An actor implementation of Unix signal handling",null,null],[3,"Signal","actix::actors::signal","Process signal message",null,null],[12,"0","","",19,null],[3,"ProcessSignals","","An actor implementation of Unix signal handling",null,null],[3,"Subscribe","","Subscribe to process signals.",null,null],[12,"0","","",20,null],[3,"DefaultSignalsHandler","","Default signals handler. This actor sends `SystemExit` message to `System` actor for each of `SIGINT`, `SIGTERM`, `SIGQUIT` signals.",null,null],[4,"SignalType","","Different types of process signals",null,null],[13,"Hup","","SIGHUP",21,null],[13,"Int","","SIGINT",21,null],[13,"Term","","SIGTERM",21,null],[13,"Quit","","SIGQUIT",21,null],[13,"Child","","SIGCHILD",21,null],[11,"eq","","",21,{"inputs":[{"name":"self"},{"name":"signaltype"}],"output":{"name":"bool"}}],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"signaltype"}}],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",22,{"inputs":[],"output":{"name":"self"}}],[11,"service_started","","",22,null],[11,"handle","","",22,null],[11,"default","","",23,{"inputs":[],"output":{"name":"self"}}],[11,"started","","",23,null],[11,"handle","","",23,null],[0,"fut","actix","Custom `Future` implementation with `Actix` support",null,null],[3,"AndThen","actix::fut","Future for the `and_then` combinator, chaining a computation onto the end of another future which completes successfully.",null,null],[3,"FromErr","","Future for the `from_err` combinator, changing the error type of a future.",null,null],[3,"Finish","","A combinator used to convert stream into a future, future resolves when stream completes.",null,null],[3,"Map","","Future for the `map` combinator, changing the type of a future.",null,null],[3,"DropErr","","",null,null],[3,"MapErr","","Future for the `map_err` combinator, changing the error type of a future.",null,null],[3,"FutureResult","","A future representing a value that is immediately ready.",null,null],[3,"StreamAndThen","","A stream combinator which chains a computation onto values produced by a stream.",null,null],[3,"StreamFinish","","A combinator used to convert stream into a future, future resolves when stream completes.",null,null],[3,"StreamFold","","A future used to collect all the results of a stream into one generic type.",null,null],[3,"StreamMap","","A stream combinator which will change the type of a stream from one type to another.",null,null],[3,"StreamMapErr","","A stream combinator which will change the error type of a stream from one type to another.",null,null],[3,"StreamThen","","A stream combinator which chains a computation onto each item produced by a stream.",null,null],[3,"StreamTimeout","","Future for the `timeout` combinator, interrupts computations if it takes more than `timeout`.",null,null],[3,"Then","","Future for the `then` combinator, chaining computations on the end of another future regardless of its outcome.",null,null],[3,"Timeout","","Future for the `timeout` combinator, interrupts computations if it takes more than `timeout`.",null,null],[3,"FutureWrap","","",null,null],[3,"StreamWrap","","",null,null],[4,"Either","","Combines two different futures yielding the same item and error types into a single type.",null,null],[13,"A","","First branch of the type",24,null],[13,"B","","Second branch of the type",24,null],[5,"err","","Creates a \"leaf future\" from an immediate value of a failed computation.",null,{"inputs":[{"name":"e"}],"output":{"name":"futureresult"}}],[5,"ok","","Creates a \"leaf future\" from an immediate value of a finished and successful computation.",null,{"inputs":[{"name":"t"}],"output":{"name":"futureresult"}}],[5,"result","","Creates a new \"leaf future\" which will resolve with the given result.",null,{"inputs":[{"name":"result"}],"output":{"name":"futureresult"}}],[5,"wrap_future","","Converts normal future into `ActorFuture`",null,{"inputs":[{"name":"f"}],"output":{"name":"futurewrap"}}],[5,"wrap_stream","","Converts normal stream into `ActorStream`",null,{"inputs":[{"name":"s"}],"output":{"name":"streamwrap"}}],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",25,null],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"split","","Splits out the homogeneous type from an either of tuples.",24,null],[11,"poll","","",24,null],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",26,null],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",27,{"inputs":[{"name":"s"}],"output":{"name":"finish"}}],[11,"poll","","",27,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",28,null],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",29,null],[11,"poll","","",30,null],[11,"fmt","","",31,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",31,null],[11,"from","","",31,{"inputs":[{"name":"result"}],"output":{"name":"self"}}],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",32,null],[11,"fmt","","",33,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",33,null],[11,"fmt","","",34,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",34,null],[11,"fmt","","",35,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",35,null],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",36,null],[11,"fmt","","",37,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",37,null],[11,"fmt","","",38,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",38,null],[11,"fmt","","",39,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",39,null],[11,"fmt","","",40,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"poll","","",40,null],[8,"ActorFuture","","Trait for types which are a placeholder of a value that may become available at some later point in time.",null,null],[16,"Item","","The type of value that this future will resolved with if it is successful.",41,null],[16,"Error","","The type of error that this future will resolve with if it fails in a normal fashion.",41,null],[16,"Actor","","The actor within which this future runs",41,null],[10,"poll","","",41,null],[11,"map","","Map this future's result to a different type, returning a new future of the resulting type.",41,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"map"}}],[11,"map_err","","Map this future's error to a different error, returning a new future.",41,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"maperr"}}],[11,"drop_err","","Drop this future's error, returning a new future.",41,{"inputs":[{"name":"self"}],"output":{"name":"droperr"}}],[11,"from_err","","Map this future's error to any error implementing `From` for this future's `Error`, returning a new future.",41,{"inputs":[{"name":"self"}],"output":{"name":"fromerr"}}],[11,"then","","Chain on a computation for when a future finished, passing the result of the future to the provided closure `f`.",41,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"then"}}],[11,"and_then","","Execute another future after this one has resolved successfully.",41,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"andthen"}}],[11,"timeout","","Add timeout to futures chain.",41,null],[8,"ActorStream","","A stream of values, not all of which may have been produced yet.",null,null],[16,"Item","","The type of item this stream will yield on success.",42,null],[16,"Error","","The type of error this stream may generate.",42,null],[16,"Actor","","The actor within which this stream runs.",42,null],[10,"poll","","",42,null],[11,"map","","Converts a stream of type `T` to a stream of type `U`.",42,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"streammap"}}],[11,"map_err","","Converts a stream of error type `T` to a stream of error type `E`.",42,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"streammaperr"}}],[11,"then","","Chain on a computation for when a value is ready, passing the resulting item to the provided closure `f`.",42,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"streamthen"}}],[11,"and_then","","Chain on a computation for when a value is ready, passing the successful results to the provided closure `f`.",42,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"streamandthen"}}],[11,"fold","","Execute an accumulating computation over a stream, collecting all the values into one final result.",42,{"inputs":[{"name":"self"},{"name":"t"},{"name":"f"}],"output":{"name":"streamfold"}}],[11,"timeout","","Add timeout to stream.",42,null],[11,"finish","","Converts a stream to a future that resolves when stream finishes.",42,{"inputs":[{"name":"self"}],"output":{"name":"streamfinish"}}],[8,"IntoActorFuture","","Class of types which can be converted into an actor future.",null,null],[16,"Future","","The future that this type can be converted into.",43,null],[16,"Item","","The item that the future may resolve with.",43,null],[16,"Error","","The error that the future may resolve with.",43,null],[16,"Actor","","The actor within which this future runs",43,null],[10,"into_future","","Consumes this object and produces a future.",43,null],[8,"WrapFuture","","Helper trait that allows conversion of normal future into `ActorFuture`",null,null],[16,"Future","","The future that this type can be converted into.",44,null],[16,"Item","","The item that the future may resolve with.",44,null],[16,"Error","","The error that the future may resolve with.",44,null],[10,"into_actor","","Convert normal future to a ActorFuture",44,null],[8,"WrapStream","","Helper trait that allows conversion of normal stream into `ActorStream`",null,null],[16,"Stream","","The stream that this type can be converted into.",45,null],[16,"Item","","The item that the future may resolve with.",45,null],[16,"Error","","The error that the future may resolve with.",45,null],[10,"into_actor","","Convert normal stream to a ActorStream",45,null],[11,"poll","","",46,null],[11,"poll","","",47,null],[0,"io","actix","",null,null],[3,"Writer","actix::io","Wrapper for `AsyncWrite` types",null,null],[3,"FramedWrite","","Wrapper for `AsyncWrite` and `Encoder` types",null,null],[8,"WriteHandler","","Write handler",null,null],[11,"error","","Method is called when writer emits error.",48,null],[11,"finished","","Method is called when writer finishes.",48,null],[11,"new","","",49,{"inputs":[{"name":"t"},{"name":"c"}],"output":{"name":"writer"}}],[11,"close","","Gracefully close sink",49,{"inputs":[{"name":"self"}],"output":null}],[11,"closed","","Check if sink is closed",49,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"set_buffer_capacity","","Set write buffer capacity",49,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":null}],[11,"write","","Send item to a sink.",49,null],[11,"handle","","`SpawnHandle` for this writer",49,{"inputs":[{"name":"self"}],"output":{"name":"spawnhandle"}}],[11,"new","","",50,{"inputs":[{"name":"t"},{"name":"u"},{"name":"c"}],"output":{"name":"framedwrite"}}],[11,"from_buffer","","",50,{"inputs":[{"name":"t"},{"name":"u"},{"name":"bytesmut"},{"name":"c"}],"output":{"name":"framedwrite"}}],[11,"close","","Gracefully close sink",50,{"inputs":[{"name":"self"}],"output":null}],[11,"closed","","Check if sink is closed",50,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"set_buffer_capacity","","Set write buffer capacity",50,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":null}],[11,"write","","Write item",50,null],[11,"handle","","`SpawnHandle` for this writer",50,{"inputs":[{"name":"self"}],"output":{"name":"spawnhandle"}}],[0,"msgs","actix","Actix system messages",null,null],[3,"SystemExit","actix::msgs","Stop system execution",null,null],[12,"0","","",51,null],[3,"StopArbiter","","Stop arbiter execution",null,null],[12,"0","","",52,null],[3,"StartActor","","Start actor in arbiter's thread",null,null],[3,"Execute","","Execute function in arbiter's thread",null,null],[11,"new","","",53,{"inputs":[{"name":"f"}],"output":{"name":"self"}}],[11,"new","","",54,{"inputs":[{"name":"f"}],"output":{"name":"self"}}],[11,"exec","","Execute enclosed function",54,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[0,"registry","actix","Actors registry",null,null],[3,"SystemRegistry","actix::registry","Actors registry",null,null],[8,"SystemService","","Trait defines system's service.",null,null],[11,"service_started","","Method is called during service initialization.",55,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}],[11,"from_registry","","Get actor's address from system registry",55,{"inputs":[],"output":{"name":"addr"}}],[11,"get","","Return address of the service. If service actor is not running it get started in system arbiter.",56,{"inputs":[{"name":"self"}],"output":{"name":"addr"}}],[11,"clone","","",56,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[0,"sync","actix","Sync actors support",null,null],[3,"SyncArbiter","actix::sync","Sync arbiter",null,null],[3,"SyncContext","","Sync actor execution context",null,null],[11,"start","","Start new sync arbiter with specified number of worker threads. Returns address of the started actor.",57,{"inputs":[{"name":"usize"},{"name":"f"}],"output":{"name":"addr"}}],[11,"pack","","",58,{"inputs":[{"name":"m"},{"generics":["syncsender"],"name":"option"}],"output":{"name":"envelope"}}],[11,"stop","","Stop current actor. SyncContext creates and starts new actor.",58,{"inputs":[{"name":"self"}],"output":null}],[11,"terminate","","Terminate actor execution. SyncContext creates and starts new actor.",58,{"inputs":[{"name":"self"}],"output":null}],[11,"state","","Actor execution state",58,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[0,"utils","actix","",null,null],[3,"Condition","actix::utils","",null,null],[11,"wait","","",59,{"inputs":[{"name":"self"}],"output":{"name":"receiver"}}],[11,"set","","",59,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"default","","",59,{"inputs":[],"output":{"name":"self"}}],[0,"prelude","actix","The `actix` prelude",null,null],[3,"SpawnHandle","actix::prelude","Spawned future handle. Could be used for cancelling spawned future.",null,null],[3,"Addr","","Address of the actor",null,null],[3,"Recipient","","`Recipient` type allows to send one specific message to an actor.",null,null],[3,"Arbiter","","Event loop controller",null,null],[3,"Context","","Actor execution context",null,null],[3,"ActorResponse","","Helper type for representing different type of message responses",null,null],[3,"MessageResult","","Helper type that implements `MessageResponse` trait",null,null],[12,"0","","",0,null],[3,"Response","","Helper type for representing different type of message responses",null,null],[3,"Supervisor","","Actor supervisor",null,null],[3,"System","","System is an actor which manages runtime.",null,null],[4,"ActorState","","Actor execution state",null,null],[13,"Started","","Actor is started.",1,null],[13,"Running","","Actor is running.",1,null],[13,"Stopping","","Actor is stopping.",1,null],[13,"Stopped","","Actor is stopped.",1,null],[4,"Running","","",null,null],[13,"Stop","","",2,null],[13,"Continue","","",2,null],[4,"MailboxError","","Set of error that can occurred during message delivery process",null,null],[13,"Closed","","",3,null],[13,"Timeout","","",3,null],[4,"SendError","","",null,null],[13,"Full","","",60,null],[13,"Closed","","",60,null],[0,"actix","","",null,null],[6,"ResponseActFuture","","A specialized actor future for async message handler",null,null],[6,"ResponseFuture","","A specialized future for async message handler",null,null],[8,"Actor","","Actors are objects which encapsulate state and behavior.",null,null],[16,"Context","","Actor execution context type",61,null],[11,"started","","Method is called when actor get polled first time.",61,null],[11,"stopping","","Method is called after an actor is in `Actor::Stopping` state. There could be several reasons for stopping. `Context::stop` get called by the actor itself. All addresses to current actor get dropped and no more evented objects left in the context.",61,null],[11,"stopped","","Method is called after an actor is stopped, it can be used to perform any needed cleanup work or spawning more actors. This is final state, after this call actor get dropped.",61,null],[11,"start","","Start new asynchronous actor, returns address of newly created actor.",61,{"inputs":[{"name":"self"}],"output":{"name":"addr"}}],[11,"start_default","","Start new asynchronous actor, returns address of newly created actor.",61,{"inputs":[],"output":{"name":"addr"}}],[11,"create","","Use `create` method, if you need `Context` object during actor initialization.",61,{"inputs":[{"name":"f"}],"output":{"name":"addr"}}],[8,"ActorContext","","Actor execution context",null,null],[10,"stop","","Immediately stop processing incoming messages and switch to a `stopping` state",62,{"inputs":[{"name":"self"}],"output":null}],[10,"terminate","","Terminate actor execution",62,{"inputs":[{"name":"self"}],"output":null}],[10,"state","","Actor execution state",62,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[8,"AsyncContext","","Asynchronous execution context",null,null],[10,"address","","Return `Address` of the context",63,{"inputs":[{"name":"self"}],"output":{"name":"addr"}}],[10,"spawn","","Spawn async future into context. Returns handle of the item, could be used for cancelling execution.",63,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[10,"wait","","Spawn future into the context. Stop processing any of incoming events until this future resolves.",63,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[10,"waiting","","Check if context is paused (waiting for future completion or stopping)",63,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"cancel_future","","Cancel future. handle is a value returned by `spawn` method.",63,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"add_stream","","This method register stream to an actor context and allows to handle `Stream` in similar way as normal actor messages.",63,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"spawnhandle"}}],[11,"add_message_stream","","This method is similar to `add_stream` but it skips stream errors.",63,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"notify","","Send message `msg` to self.",63,{"inputs":[{"name":"self"},{"name":"m"}],"output":null}],[11,"notify_later","","Send message `msg` to self after specified period of time. Returns spawn handle which could be used for cancellation. Notification get cancelled if context's stop method get called.",63,{"inputs":[{"name":"self"},{"name":"m"},{"name":"duration"}],"output":{"name":"spawnhandle"}}],[11,"run_later","","Execute closure after specified period of time within same Actor and Context. Execution get cancelled if context's stop method get called.",63,{"inputs":[{"name":"self"},{"name":"duration"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[8,"Supervised","","Actors with ability to restart after failure",null,null],[11,"restarting","","Method called when supervisor restarting failed actor",64,null],[8,"ContextFutureSpawner","","Helper trait which can spawn future into actor's context",null,null],[10,"spawn","","spawn future into `Context<A>`",65,null],[10,"wait","","Spawn future into the context. Stop processing any of incoming events until this future resolves.",65,null],[8,"Handler","","Message handler",null,null],[16,"Result","","The type of value that this handle will return",66,null],[10,"handle","","Method is called for every message received by this Actor",66,null],[8,"Message","","Message type",null,null],[16,"Result","","The type of value that this message will resolved with if it is successful.",67,null],[8,"StreamHandler","","Stream handler",null,null],[10,"handle","","Method is called for every message received by this Actor",68,null],[11,"started","","Method is called when stream get polled first time.",68,null],[11,"error","","Method is called when stream emits error.",68,null],[11,"finished","","Method is called when stream finishes.",68,null],[11,"add_stream","","This method register stream to an actor context and allows to handle `Stream` in similar way as normal actor messages.",68,null],[0,"dev","actix","The `actix` prelude for library developers",null,null],[3,"Envelope","actix::dev","",null,null],[3,"RecipientRequest","","`RecipientRequest` is a `Future` which represents asynchronous message sending process.",null,null],[3,"Request","","`Request` is a `Future` which represents asynchronous message sending process.",null,null],[3,"ContextImpl","","Actor execution context impl",null,null],[8,"ToEnvelope","","Converter trait, packs message to suitable envelope",null,null],[10,"pack","","Pack message into suitable envelope",69,{"inputs":[{"name":"m"},{"generics":["sender"],"name":"option"}],"output":{"name":"envelope"}}],[8,"MessageResponse","","Trait which defines message response",null,null],[10,"handle","","",70,null],[8,"ResponseChannel","","Trait defines message response channel",null,null],[10,"is_canceled","","",71,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"send","","",71,null],[6,"ResponseActFuture","actix","A specialized actor future for async message handler",null,null],[6,"ResponseFuture","","A specialized future for async message handler",null,null],[8,"Actor","","Actors are objects which encapsulate state and behavior.",null,null],[16,"Context","","Actor execution context type",61,null],[11,"started","actix::prelude","Method is called when actor get polled first time.",61,null],[11,"stopping","","Method is called after an actor is in `Actor::Stopping` state. There could be several reasons for stopping. `Context::stop` get called by the actor itself. All addresses to current actor get dropped and no more evented objects left in the context.",61,null],[11,"stopped","","Method is called after an actor is stopped, it can be used to perform any needed cleanup work or spawning more actors. This is final state, after this call actor get dropped.",61,null],[11,"start","","Start new asynchronous actor, returns address of newly created actor.",61,{"inputs":[{"name":"self"}],"output":{"name":"addr"}}],[11,"start_default","","Start new asynchronous actor, returns address of newly created actor.",61,{"inputs":[],"output":{"name":"addr"}}],[11,"create","","Use `create` method, if you need `Context` object during actor initialization.",61,{"inputs":[{"name":"f"}],"output":{"name":"addr"}}],[8,"ActorContext","actix","Actor execution context",null,null],[10,"stop","","Immediately stop processing incoming messages and switch to a `stopping` state",62,{"inputs":[{"name":"self"}],"output":null}],[10,"terminate","","Terminate actor execution",62,{"inputs":[{"name":"self"}],"output":null}],[10,"state","","Actor execution state",62,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[8,"AsyncContext","","Asynchronous execution context",null,null],[10,"address","","Return `Address` of the context",63,{"inputs":[{"name":"self"}],"output":{"name":"addr"}}],[10,"spawn","","Spawn async future into context. Returns handle of the item, could be used for cancelling execution.",63,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[10,"wait","","Spawn future into the context. Stop processing any of incoming events until this future resolves.",63,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[10,"waiting","","Check if context is paused (waiting for future completion or stopping)",63,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"cancel_future","","Cancel future. handle is a value returned by `spawn` method.",63,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"add_stream","actix::prelude","This method register stream to an actor context and allows to handle `Stream` in similar way as normal actor messages.",63,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"spawnhandle"}}],[11,"add_message_stream","","This method is similar to `add_stream` but it skips stream errors.",63,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"notify","","Send message `msg` to self.",63,{"inputs":[{"name":"self"},{"name":"m"}],"output":null}],[11,"notify_later","","Send message `msg` to self after specified period of time. Returns spawn handle which could be used for cancellation. Notification get cancelled if context's stop method get called.",63,{"inputs":[{"name":"self"},{"name":"m"},{"name":"duration"}],"output":{"name":"spawnhandle"}}],[11,"run_later","","Execute closure after specified period of time within same Actor and Context. Execution get cancelled if context's stop method get called.",63,{"inputs":[{"name":"self"},{"name":"duration"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[8,"Supervised","actix","Actors with ability to restart after failure",null,null],[11,"restarting","actix::prelude","Method called when supervisor restarting failed actor",64,null],[8,"Handler","actix","Message handler",null,null],[16,"Result","","The type of value that this handle will return",66,null],[10,"handle","","Method is called for every message received by this Actor",66,null],[8,"Message","","Message type",null,null],[16,"Result","","The type of value that this message will resolved with if it is successful.",67,null],[8,"StreamHandler","","Stream handler",null,null],[10,"handle","","Method is called for every message received by this Actor",68,null],[11,"started","actix::prelude","Method is called when stream get polled first time.",68,null],[11,"error","","Method is called when stream emits error.",68,null],[11,"finished","","Method is called when stream finishes.",68,null],[11,"add_stream","","This method register stream to an actor context and allows to handle `Stream` in similar way as normal actor messages.",68,null],[11,"started","","Method is called when actor get polled first time.",61,null],[11,"stopping","","Method is called after an actor is in `Actor::Stopping` state. There could be several reasons for stopping. `Context::stop` get called by the actor itself. All addresses to current actor get dropped and no more evented objects left in the context.",61,null],[11,"stopped","","Method is called after an actor is stopped, it can be used to perform any needed cleanup work or spawning more actors. This is final state, after this call actor get dropped.",61,null],[11,"start","","Start new asynchronous actor, returns address of newly created actor.",61,{"inputs":[{"name":"self"}],"output":{"name":"addr"}}],[11,"start_default","","Start new asynchronous actor, returns address of newly created actor.",61,{"inputs":[],"output":{"name":"addr"}}],[11,"create","","Use `create` method, if you need `Context` object during actor initialization.",61,{"inputs":[{"name":"f"}],"output":{"name":"addr"}}],[11,"restarting","","Method called when supervisor restarting failed actor",64,null],[11,"add_stream","","This method register stream to an actor context and allows to handle `Stream` in similar way as normal actor messages.",63,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"spawnhandle"}}],[11,"add_message_stream","","This method is similar to `add_stream` but it skips stream errors.",63,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"notify","","Send message `msg` to self.",63,{"inputs":[{"name":"self"},{"name":"m"}],"output":null}],[11,"notify_later","","Send message `msg` to self after specified period of time. Returns spawn handle which could be used for cancellation. Notification get cancelled if context's stop method get called.",63,{"inputs":[{"name":"self"},{"name":"m"},{"name":"duration"}],"output":{"name":"spawnhandle"}}],[11,"run_later","","Execute closure after specified period of time within same Actor and Context. Execution get cancelled if context's stop method get called.",63,{"inputs":[{"name":"self"},{"name":"duration"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[11,"new","actix::dev","",72,{"inputs":[{"name":"option"}],"output":{"name":"contextimpl"}}],[11,"with_receiver","","",72,{"inputs":[{"name":"option"},{"name":"addressreceiver"}],"output":{"name":"self"}}],[11,"actor","","Mutable reference to an actor.",72,{"inputs":[{"name":"self"}],"output":{"name":"a"}}],[11,"modify","","Mark context as modified, this cause extra poll loop over all items",72,{"inputs":[{"name":"self"}],"output":null}],[11,"waiting","","Is context waiting for future completion",72,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"stop","","Initiate stop process for actor execution",72,{"inputs":[{"name":"self"}],"output":null}],[11,"terminate","","Terminate actor execution",72,{"inputs":[{"name":"self"}],"output":null}],[11,"state","","Actor execution state",72,{"inputs":[{"name":"self"}],"output":{"name":"actorstate"}}],[11,"curr_handle","","Handle of the running future",72,{"inputs":[{"name":"self"}],"output":{"name":"spawnhandle"}}],[11,"spawn","","Spawn new future to this context.",72,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"spawnhandle"}}],[11,"wait","","Spawn new future to this context and wait future completion.",72,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"cancel_future","","Cancel previously scheduled future.",72,{"inputs":[{"name":"self"},{"name":"spawnhandle"}],"output":{"name":"bool"}}],[11,"capacity","","",72,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"set_mailbox_capacity","","",72,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"address","","",72,{"inputs":[{"name":"self"}],"output":{"name":"addr"}}],[11,"alive","","",72,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"restart","","Restart context. Cleanup all futures, except address queue.",72,null],[11,"set_actor","","",72,{"inputs":[{"name":"self"},{"name":"a"}],"output":null}],[11,"into_inner","","",72,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"started","","",72,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"poll","","",72,null],[11,"handle","actix::prelude","",73,null],[11,"handle","","",74,null],[11,"started","","Method is called when stream get polled first time.",68,null],[11,"error","","Method is called when stream emits error.",68,null],[11,"finished","","Method is called when stream finishes.",68,null],[11,"add_stream","","This method register stream to an actor context and allows to handle `Stream` in similar way as normal actor messages.",68,null],[11,"new","actix::dev","",75,{"inputs":[{"name":"m"},{"generics":["sender"],"name":"option"}],"output":{"name":"envelope"}}],[11,"with_proxy","","",75,{"inputs":[{"generics":["envelopeproxy"],"name":"box"}],"output":{"name":"envelope"}}],[11,"timeout","","Set message delivery timeout",76,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"self"}}],[11,"poll","","",76,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"new","","",77,{"inputs":[{"generics":["receiver"],"name":"option"},{"name":"option"}],"output":{"name":"recipientrequest"}}],[11,"timeout","","Set message delivery timeout",77,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"self"}}],[11,"poll","","",77,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"into_inner","actix::prelude","",60,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"fmt","","",60,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",60,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}]],"paths":[[3,"MessageResult"],[4,"ActorState"],[4,"Running"],[4,"MailboxError"],[3,"SpawnHandle"],[3,"Arbiter"],[3,"Context"],[3,"Addr"],[3,"Response"],[3,"ActorResponse"],[3,"Supervisor"],[3,"System"],[3,"SystemRuntime"],[3,"Recipient"],[3,"ConnectAddr"],[4,"ConnectorError"],[3,"Resolve"],[3,"Connect"],[3,"Connector"],[3,"Signal"],[3,"Subscribe"],[4,"SignalType"],[3,"ProcessSignals"],[3,"DefaultSignalsHandler"],[4,"Either"],[3,"AndThen"],[3,"FromErr"],[3,"Finish"],[3,"Map"],[3,"MapErr"],[3,"DropErr"],[3,"FutureResult"],[3,"StreamAndThen"],[3,"StreamFinish"],[3,"StreamFold"],[3,"StreamMap"],[3,"StreamMapErr"],[3,"StreamThen"],[3,"StreamTimeout"],[3,"Then"],[3,"Timeout"],[8,"ActorFuture"],[8,"ActorStream"],[8,"IntoActorFuture"],[8,"WrapFuture"],[8,"WrapStream"],[3,"FutureWrap"],[3,"StreamWrap"],[8,"WriteHandler"],[3,"Writer"],[3,"FramedWrite"],[3,"SystemExit"],[3,"StopArbiter"],[3,"StartActor"],[3,"Execute"],[8,"SystemService"],[3,"SystemRegistry"],[3,"SyncArbiter"],[3,"SyncContext"],[3,"Condition"],[4,"SendError"],[8,"Actor"],[8,"ActorContext"],[8,"AsyncContext"],[8,"Supervised"],[8,"ContextFutureSpawner"],[8,"Handler"],[8,"Message"],[8,"StreamHandler"],[8,"ToEnvelope"],[8,"MessageResponse"],[8,"ResponseChannel"],[3,"ContextImpl"],[6,"ResponseActFuture"],[6,"ResponseFuture"],[3,"Envelope"],[3,"Request"],[3,"RecipientRequest"]]};
initSearch(searchIndex);
